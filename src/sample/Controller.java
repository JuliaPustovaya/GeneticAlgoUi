package sample;

import Exp3.*;
import GA.*;
import SA.GA.KCleanStaticVariables;
import SA.GA.KGAparametrs;
import SA.ReadDataFromFile;
import SA.SA_main;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.NumberAxis;
import javafx.scene.control.*;
import javafx.stage.Stage;

import java.io.IOException;
import java.net.URL;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.ResourceBundle;

import static Exp3.Coefficients.*;
import static Exp3.ErrorCoeficients.MSE;
import static Exp3.Forecasting.printForecastedValues;
import static Exp3.UpdatedTimeSeria.getUpdatedTimeSeria;
import static GA.CleanStaticVariables.cleanStaticVariables;
import static GA.Crossover.childrenListAfterCrossover;
import static SA.GA.KGAparametrs.*;
import static SA.GA.RunAll.K_MSE;
import static SA.GA.RunAll.datafromfile;
import static SA.SA_main.X_list_SA;

public class Controller implements Initializable {

    public static String globalFilePath;
    public static String IdClickedAnalysisBtn;

    @FXML
    public LineChart lineChart, lineChart2;
    @FXML
    public Button forecast, autogenerated, loaddate1, savedate1, cleandate1, btnOpenNewWindow,btnOpenNewWindowK;
    @FXML
    public TextField textFieldL, textFieldm, alfa, betta, gamma, amountForecastingK, kNearest, mNearest;
    @FXML
    public NumberAxis xAxis, yAxis;
    @FXML
    public Label mse1, mape1;
    @FXML
    public ListView list1InitialData, list1IPredictedData, list2InitialData, list2IPredictedData, vectorHistoryView;

    @FXML
    public void getInputCoefficientsForecast(ActionEvent ev) {
        list1IPredictedData.getItems().clear();
        L = Integer.parseInt(textFieldL.getText());
        m = Integer.parseInt(textFieldm.getText());
        ALFA = Double.parseDouble(alfa.getText());
        BETTA = Double.parseDouble(betta.getText());
        GAMMA = Double.parseDouble(gamma.getText());
        ReadFromFile.splitInitialTimeSeriaIntoRealandTimerseriaData(readedTimeSeriaFromFile);
        makeForecastByInput(lineChart, textFieldL, textFieldm, list1IPredictedData, alfa, betta, gamma);
        mse1.setText(new DecimalFormat("#0.00").format(ErrorCoeficients.MSE));
        mape1.setText(new DecimalFormat("#0.00").format(ErrorCoeficients.E));

    }

    @FXML
    public void getAutogenerated(ActionEvent ev) {
        m = Integer.parseInt(textFieldm.getText());
        L = Integer.parseInt(textFieldL.getText());
        ReadFromFile.splitInitialTimeSeriaIntoRealandTimerseriaData(readedTimeSeriaFromFile);
        GA(lineChart);
        ReflactionDataInListViews.reflactDataIntoLists(list1IPredictedData, realResult, forecastResult);
        mse1.setText(new DecimalFormat("#0.000").format(ErrorCoeficients.MSE));
        mape1.setText(new DecimalFormat("#0.000").format(ErrorCoeficients.E));

    }

    @FXML
    public void loadDate1(ActionEvent ev) {
        try {
            readedTimeSeriaFromFile.clear();
            timeSeria.clear();
            updatedTimeSerias.clear();
            realResult.clear();
            mse1.setText("");
            mape1.setText("");
            ReadFromFile.openFile();
        } catch (Exception ex) {
        }
        ReflactionDataInListViews.reflactDataIntoListView(list1InitialData, readedTimeSeriaFromFile);
        BuildingCharts.buildChart(lineChart, readedTimeSeriaFromFile);
        textFieldL.requestFocus();

    }

    @FXML
    public void saveDate1(ActionEvent ev) {
    }

    @FXML
    public void cleanDate1(ActionEvent ev) {
        readedTimeSeriaFromFile.clear();
        timeSeria.clear();
        list1InitialData.getItems().clear();
        list1IPredictedData.getItems().clear();
        lineChart.getData().clear();
        cleanStaticVariables();
        Cleaning.cleanVaribles();

    }

    public static ArrayList<TimeSeria> timeSeria = new ArrayList<TimeSeria>();
    public static ArrayList<TimeSeria> readedTimeSeriaFromFile = new ArrayList<TimeSeria>();
    public static ArrayList<UpdatedTimeSeria> updatedTimeSerias = new ArrayList<UpdatedTimeSeria>();
    public static ArrayList<Double> realResult = new ArrayList<>();
    public static ArrayList<Double> forecastResult = new ArrayList<>();
//K-nearest

    @Override
    public void initialize(URL url, ResourceBundle rb) {
        showAlert();
    }

    public void showAlert() {
        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("УВАГА!");
        alert.setHeaderText("Пропущені важливі дані");
        alert.setContentText("Будь ласка, заповність необхідні параметри прогнозування !");
        alert.showAndWait();
        //  button.setDisable(false);
    }

    public static void makeForecastByInput(LineChart lineChart1, TextField textFieldL, TextField textFieldm, ListView l, TextField alfa, TextField betta, TextField gamma) {
        updatedTimeSerias.clear();
        forecastResult.clear();
        System.out.println("Alfa= " + ALFA + ", Betta=  " + BETTA + ", Gamma=  " + GAMMA + ", Season=  " + L + " Quantity  of preficted data=  " + m);
        InitialIndexis initialIndexis = new InitialIndexis();
        initialIndexis.formS0();
        initialIndexis.formB0();
        initialIndexis.formC0();
        System.out.println("s0 " + initialIndexis.getS0() + "\n" + "b0 " + initialIndexis.getB0() + "\n" + "c0 " + initialIndexis.getC0());
        FormattedIndexis formattedIndexis = new FormattedIndexis();
        for (int i = 1; i <= timeSeria.size(); i++) {
            formattedIndexis.formSt(i);
        }
        getUpdatedTimeSeria();
        Forecasting forecasting = new Forecasting();
        forecasting.getForecastedValues(updatedTimeSerias, m);
        printForecastedValues(forecastResult);
        ErrorCoeficients.getMSE(realResult, forecastResult);
        ErrorCoeficients.getE(realResult, forecastResult);
        BuildingCharts.buildChart(lineChart1, timeSeria, realResult, forecastResult);
        ReflactionDataInListViews.reflactDataIntoLists(l, realResult, forecastResult);
    }

    public static void getFitnessFunctionGA(double alfaXromocom, double bettaXromocom, double gammaXromocoma) {
        updatedTimeSerias.clear();
        forecastResult.clear();
        ALFA = alfaXromocom;
        BETTA = bettaXromocom;
        GAMMA = gammaXromocoma;
        System.out.println("Alfa= " + ALFA + ", Betta=  " + BETTA + ", Gamma=  " + GAMMA + ", Season=  " + L + " Quantity  of preficted data=  " + m);
        InitialIndexis initialIndexis = new InitialIndexis();
        initialIndexis.formS0();
        initialIndexis.formB0();
        initialIndexis.formC0();
        System.out.println("s0 " + initialIndexis.getS0() + "\n" + "b0 " + initialIndexis.getB0() + "\n" + "c0 " + initialIndexis.getC0());
        FormattedIndexis formattedIndexis = new FormattedIndexis();
        for (int i = 1; i <= timeSeria.size(); i++) {
            formattedIndexis.formSt(i);
        }
        getUpdatedTimeSeria();
        Forecasting forecasting = new Forecasting();
        forecasting.getForecastedValues(updatedTimeSerias, m);
        printForecastedValues(forecastResult);
        ErrorCoeficients.getMSE(realResult, forecastResult);
        ErrorCoeficients.getE(realResult, forecastResult);

    }

    public static void GA(LineChart lineChart1) {
        Population.makeRandomPopulation();
        //      for (int i = 0; i < 10; i++)
        while (MSE > 1) {
            Population.makeRuletSelection();
            Selection.getParentsPairsForSelections(Population.selectedParentsForSelection);
            Crossover.getChidrenPairsDiscreteCrossover(Selection.parentsPairsForSelections);
            Mutation.RandomMutation(childrenListAfterCrossover);
            NewPopulation.selectXromocomaInNewPopulation(NewPopulation.formNewPopulation(Population.populationXromocoma, Mutation.childrenAfterMutation));

        }
        BuildingCharts.buildChart(lineChart1, timeSeria, realResult, forecastResult);

    }

    public static double getFitness(double alfa, double beta, double gam) {
        MSE = 0.0;
        getFitnessFunctionGA(alfa, beta, gam);
        return MSE;
    }

    @FXML
    public void loadDate2(ActionEvent ev) {
        try {
            ReadDataFromFile.openFile();
        } catch (Exception e) {
            e.printStackTrace();
        }
        BuildingCharts.buildChartDouble(lineChart2, datafromfile);
        ReflactionDataInListViews.reflactDataIntoListViewDouble(list2InitialData, datafromfile);

    }

    @FXML
    public void getInputCoefficientsForecastK(ActionEvent ev) {
        KCleanStaticVariables.cleanStaticVariables();
        SA.SA_main.X_list_SA_EVKLIDOV.clear();
        amountForecasting = Integer.parseInt(amountForecastingK.getText());
        K = Integer.parseInt(kNearest.getText());
        M = Integer.parseInt(kNearest.getText());
        for (int i = 0; i < datafromfile.size() - amountForecasting; i++) {
            X_list_SA.add(datafromfile.get(i));
        }
        N = X_list_SA.size();
        SA.SA_main.X_list_SA_EVKLIDOV.addAll(SA.SA_main.X_list_SA);
        SA.SA_main SA = new SA_main();
        SA.Z_list_vector_history_evklidov.clear();
        SA.Z_sorted_distance_Evklid_SA.clear();
        SA.nn_Evklid_SA.clear();
        for (int i = 0; i < amountForecasting; i++) {
            SA.Z_list_vector_history_evklidov = ReadDataFromFile.FormListOfZ_vector_histories(SA_main.X_list_SA_EVKLIDOV, M);
            if (i == 0) {
                ReflactionDataInListViews.reflactVectorHistoryIntoList(vectorHistoryView, SA.Z_list_vector_history_evklidov);

            }
            SA.Z_sorted_distance_Evklid_SA = ReadDataFromFile.Evklidova_distance(SA.Z_list_vector_history_evklidov);
            SA.nn_Evklid_SA = ReadDataFromFile.pois_K_nearest(SA.Z_sorted_distance_Evklid_SA, K);
            SA.poisk_next_forecasting_meaning(SA.nn_Evklid_SA, SA.Z_list_vector_history_evklidov, SA_main.X_list_SA_EVKLIDOV);
        }
        System.out.println("Forecasted: " + SA_main.X_list_SA_EVKLIDOV);
        System.out.println(K_MSE(SA_main.X_list_SA_EVKLIDOV, datafromfile, K));
        BuildingCharts.buildChartDouble(lineChart2, datafromfile, SA_main.X_list_SA_EVKLIDOV);
        ReflactionDataInListViews.reflactDataIntoListsDouble(list2IPredictedData, datafromfile, SA_main.X_list_SA_EVKLIDOV);
    }

    @FXML
    public void openNewWindow(ActionEvent ev) {
        try {
           Button b= (Button) ev.getSource();
            IdClickedAnalysisBtn=  b.getId();
            FXMLLoader fxmlLoader = new FXMLLoader();
            fxmlLoader.setLocation(getClass().getResource("FXMLDocument.fxml"));
            Scene scene = new Scene(fxmlLoader.load());
            Stage stage = new Stage();
            stage.setTitle("Характеристики динамічного ряду");
            stage.setScene(scene);
            stage.show();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @FXML
    public void openNewWindowK(ActionEvent ev) {
        try {
            Button b= (Button) ev.getSource();
            IdClickedAnalysisBtn=  b.getId();
            FXMLLoader fxmlLoader = new FXMLLoader();
            fxmlLoader.setLocation(getClass().getResource("FXMLDocument.fxml"));
            Scene scene = new Scene(fxmlLoader.load());
            Stage stage = new Stage();
            stage.setTitle("Характеристики динамічного ряду");
            stage.setScene(scene);
            stage.show();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}